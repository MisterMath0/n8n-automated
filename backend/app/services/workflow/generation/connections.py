"""
Connection Builder Tool - Third step in multi-step workflow generation.
Creates connections between N8N workflow nodes based on plan and generated nodes.
"""

from typing import Dict, Any
import structlog

from ...tools.base_tool import BaseTool
from ....models.conversation import ToolCall, ToolResult
from ....models.workflow import AIModel
from ..schemas import create_workflow_connections_schema
from ....core.config_loader import config_loader

logger = structlog.get_logger()


class ConnectionBuilderTool(BaseTool):
    """Tool for building connections between workflow nodes"""
    
    @property
    def name(self) -> str:
        return "connection_builder"
    
    @property
    def description(self) -> str:
        return "Create connections between N8N workflow nodes based on plan and generated nodes"
    
    @property
    def input_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "workflow_plan": {
                    "type": "object",
                    "description": "Original workflow plan"
                },
                "generated_nodes": {
                    "type": "array",
                    "description": "Array of generated nodes to connect"
                }
            },
            "required": ["workflow_plan", "generated_nodes"]
        }
    
    async def execute(self, tool_call: ToolCall) -> ToolResult:
        """Execute connection building (delegate to execute_with_model)"""
        return await self.execute_with_model(tool_call, AIModel.GEMINI_2_5_FLASH)
    
    async def execute_with_model(self, tool_call: ToolCall, model: AIModel) -> ToolResult:
        """Execute connection building with AI model"""
        try:
            workflow_plan = tool_call.parameters.get("workflow_plan", {})
            nodes = tool_call.parameters.get("generated_nodes", [])
            
            if not workflow_plan:
                return self._create_error_result(tool_call, "Workflow plan is required")
            if not nodes:
                return self._create_error_result(tool_call, "Generated nodes are required")
            
            # Get connection prompt from config
            prompts_config = config_loader.load_config("prompts")
            connection_prompt = prompts_config["tools"]["connection_builder"]["system_prompt"]
            
            # Build full prompt
            full_prompt = f"{connection_prompt}\n\nWorkflow Plan: {workflow_plan}\nNodes: {nodes}"
            
            try:
                # Call AI service with simple connections schema
                result = await self._call_ai_with_schema(
                    prompt=full_prompt,
                    schema=create_workflow_connections_schema(),
                    model=model
                )
                
                # Convert simple connections to N8N format
                simple_connections = result.get("connections", [])
                n8n_connections = self._convert_to_n8n_connections(simple_connections, nodes)
                
                logger.info("Connections generated by AI", 
                           connections_count=len(simple_connections),
                           model=model.value)
                
            except Exception as ai_error:
                logger.warning("AI connection generation failed, using fallback", error=str(ai_error))
                # Fallback to sequential connections
                n8n_connections = self._create_sequential_connections(nodes)
            
            return self._create_success_result(tool_call, {
                "connections": n8n_connections,
                "connection_success": True,
                "connections_count": len(n8n_connections)
            })
            
        except Exception as e:
            logger.error("Connection building failed", error=str(e), model=model.value)
            return self._create_error_result(tool_call, f"Connection building failed: {str(e)}")
    
    def _convert_to_n8n_connections(self, simple_connections: list, nodes: list) -> Dict:
        """Convert simple connection format to N8N connections format"""
        n8n_connections = {}
        
        # Create a mapping of node names for validation
        node_names = {node.get("name") for node in nodes if node.get("name")}
        logger.debug("Node names available for connections", node_names=list(node_names), nodes=nodes)
        logger.debug("Simple connections input from AI", simple_connections=simple_connections)
        
        for conn in simple_connections:
            logger.debug("Processing connection", connection=conn)
            if not isinstance(conn, dict):
                logger.warning("Connection is not a dict", connection=conn)
                continue
                
            source = conn.get("source_node")
            target = conn.get("target_node")
            conn_type = conn.get("connection_type", "main")
            target_index = conn.get("target_index", 0)
            
            # Validate node names exist
            if source not in node_names or target not in node_names:
                logger.warning(f"Invalid connection: {source} -> {target} (nodes not found)",
                               source=source, target=target, node_names=list(node_names),
                               all_nodes=nodes, connection=conn)
                continue
            
            if source not in n8n_connections:
                n8n_connections[source] = {}
            
            if conn_type not in n8n_connections[source]:
                n8n_connections[source][conn_type] = []
            
            # Ensure we have the right number of output groups
            while len(n8n_connections[source][conn_type]) <= 0:
                n8n_connections[source][conn_type].append([])
            
            n8n_connections[source][conn_type][0].append({
                "node": target,
                "type": conn_type,
                "index": target_index
            })
        
        logger.debug("Final N8N connections generated", n8n_connections=n8n_connections)
        return n8n_connections
    
    def _create_sequential_connections(self, nodes: list) -> Dict:
        """Create fallback sequential connections"""
        connections = {}
        
        if len(nodes) < 2:
            return connections
        
        for i in range(len(nodes) - 1):
            source_name = nodes[i].get("name")
            target_name = nodes[i + 1].get("name")
            
            if not source_name or not target_name:
                continue
            
            connections[source_name] = {
                "main": [[{
                    "node": target_name,
                    "type": "main", 
                    "index": 0
                }]]
            }
        
        logger.info(f"Generated {len(connections)} sequential connections as fallback")
        return connections
